/*
 * generated by Xtext 2.19.0
 */
package org.xtext.sosModeling.archModeling.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.sosModeling.archModeling.hSFDSL.AElementsBehaviorRoutines;
import org.xtext.sosModeling.archModeling.hSFDSL.AbsArchDecl;
import org.xtext.sosModeling.archModeling.hSFDSL.AddAElements;
import org.xtext.sosModeling.archModeling.hSFDSL.Askopeator;
import org.xtext.sosModeling.archModeling.hSFDSL.BindElements;
import org.xtext.sosModeling.archModeling.hSFDSL.BooleanLiteral;
import org.xtext.sosModeling.archModeling.hSFDSL.CColActions;
import org.xtext.sosModeling.archModeling.hSFDSL.CConsDecl;
import org.xtext.sosModeling.archModeling.hSFDSL.CSDecl;
import org.xtext.sosModeling.archModeling.hSFDSL.CSMembersDefintion;
import org.xtext.sosModeling.archModeling.hSFDSL.ControlDecisions;
import org.xtext.sosModeling.archModeling.hSFDSL.DefineMediationRoles;
import org.xtext.sosModeling.archModeling.hSFDSL.EqualityExpression;
import org.xtext.sosModeling.archModeling.hSFDSL.ExponentialRates;
import org.xtext.sosModeling.archModeling.hSFDSL.FLOAT;
import org.xtext.sosModeling.archModeling.hSFDSL.GlobalProperties;
import org.xtext.sosModeling.archModeling.hSFDSL.HSFDSLPackage;
import org.xtext.sosModeling.archModeling.hSFDSL.IntegerLiteral;
import org.xtext.sosModeling.archModeling.hSFDSL.LogicalExpression;
import org.xtext.sosModeling.archModeling.hSFDSL.MedDecl;
import org.xtext.sosModeling.archModeling.hSFDSL.MedRoleDeclaration;
import org.xtext.sosModeling.archModeling.hSFDSL.MinusOperation;
import org.xtext.sosModeling.archModeling.hSFDSL.ModelElementsDecaration;
import org.xtext.sosModeling.archModeling.hSFDSL.NegationExpression;
import org.xtext.sosModeling.archModeling.hSFDSL.ProtDeclaration;
import org.xtext.sosModeling.archModeling.hSFDSL.RealLiteral;
import org.xtext.sosModeling.archModeling.hSFDSL.RelationalExpression;
import org.xtext.sosModeling.archModeling.hSFDSL.StochasticModeling;
import org.xtext.sosModeling.archModeling.hSFDSL.StochsticBehaviors;
import org.xtext.sosModeling.archModeling.hSFDSL.StringLiteral;
import org.xtext.sosModeling.archModeling.hSFDSL.SumOperation;
import org.xtext.sosModeling.archModeling.hSFDSL.Telloperator;
import org.xtext.sosModeling.archModeling.hSFDSL.Term;
import org.xtext.sosModeling.archModeling.hSFDSL.VariableRef;
import org.xtext.sosModeling.archModeling.hSFDSL.attachCSs;
import org.xtext.sosModeling.archModeling.hSFDSL.detachCSs;
import org.xtext.sosModeling.archModeling.hSFDSL.formalParameter;
import org.xtext.sosModeling.archModeling.hSFDSL.formalParameterList;
import org.xtext.sosModeling.archModeling.hSFDSL.formalParameters;
import org.xtext.sosModeling.archModeling.hSFDSL.functinality;
import org.xtext.sosModeling.archModeling.hSFDSL.initVals;
import org.xtext.sosModeling.archModeling.hSFDSL.publicinterfaeceDef;
import org.xtext.sosModeling.archModeling.hSFDSL.traitDeclaration;
import org.xtext.sosModeling.archModeling.hSFDSL.variableDeclaratorId;
import org.xtext.sosModeling.archModeling.services.SFDSLGrammarAccess;

@SuppressWarnings("all")
public class SFDSLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SFDSLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == HSFDSLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case HSFDSLPackage.AELEMENTS_BEHAVIOR_ROUTINES:
				sequence_AElementsBehaviorRoutines(context, (AElementsBehaviorRoutines) semanticObject); 
				return; 
			case HSFDSLPackage.ABS_ARCH_DECL:
				sequence_AbsArchDecl(context, (AbsArchDecl) semanticObject); 
				return; 
			case HSFDSLPackage.ADD_AELEMENTS:
				sequence_AddAElements(context, (AddAElements) semanticObject); 
				return; 
			case HSFDSLPackage.ASKOPEATOR:
				sequence_Askopeator(context, (Askopeator) semanticObject); 
				return; 
			case HSFDSLPackage.BIND_ELEMENTS:
				sequence_BindElements(context, (BindElements) semanticObject); 
				return; 
			case HSFDSLPackage.BOOLEAN_LITERAL:
				sequence_BooleanLiteral(context, (BooleanLiteral) semanticObject); 
				return; 
			case HSFDSLPackage.CCOL_ACTIONS:
				sequence_CColActions(context, (CColActions) semanticObject); 
				return; 
			case HSFDSLPackage.CCONS_DECL:
				sequence_CConsDecl(context, (CConsDecl) semanticObject); 
				return; 
			case HSFDSLPackage.CS_DECL:
				sequence_CSDecl(context, (CSDecl) semanticObject); 
				return; 
			case HSFDSLPackage.CS_MEMBERS_DEFINTION:
				sequence_CSMembersDefintion(context, (CSMembersDefintion) semanticObject); 
				return; 
			case HSFDSLPackage.CONTROL_DECISIONS:
				sequence_ControlDecisions(context, (ControlDecisions) semanticObject); 
				return; 
			case HSFDSLPackage.DEFINE_MEDIATION_ROLES:
				sequence_DefineMediationRoles(context, (DefineMediationRoles) semanticObject); 
				return; 
			case HSFDSLPackage.EQUALITY_EXPRESSION:
				sequence_EqualityExpression(context, (EqualityExpression) semanticObject); 
				return; 
			case HSFDSLPackage.EXPONENTIAL_RATES:
				sequence_ExponentialRates(context, (ExponentialRates) semanticObject); 
				return; 
			case HSFDSLPackage.FLOAT:
				sequence_FLOAT(context, (FLOAT) semanticObject); 
				return; 
			case HSFDSLPackage.GLOBAL_PROPERTIES:
				sequence_GlobalProperties(context, (GlobalProperties) semanticObject); 
				return; 
			case HSFDSLPackage.INTEGER_LITERAL:
				sequence_IntegerLiteral(context, (IntegerLiteral) semanticObject); 
				return; 
			case HSFDSLPackage.LOGICAL_EXPRESSION:
				sequence_LogicalExpression(context, (LogicalExpression) semanticObject); 
				return; 
			case HSFDSLPackage.MED_DECL:
				sequence_MedDecl(context, (MedDecl) semanticObject); 
				return; 
			case HSFDSLPackage.MED_ROLE_DECLARATION:
				sequence_MedRoleDeclaration(context, (MedRoleDeclaration) semanticObject); 
				return; 
			case HSFDSLPackage.MINUS_OPERATION:
				sequence_ArithmeticExpression(context, (MinusOperation) semanticObject); 
				return; 
			case HSFDSLPackage.MODEL_ELEMENTS_DECARATION:
				sequence_ModelElementsDecaration(context, (ModelElementsDecaration) semanticObject); 
				return; 
			case HSFDSLPackage.NEGATION_EXPRESSION:
				sequence_UnaryExpression(context, (NegationExpression) semanticObject); 
				return; 
			case HSFDSLPackage.PROT_DECLARATION:
				sequence_ProtDeclaration(context, (ProtDeclaration) semanticObject); 
				return; 
			case HSFDSLPackage.REAL_LITERAL:
				sequence_RealLiteral(context, (RealLiteral) semanticObject); 
				return; 
			case HSFDSLPackage.RELATIONAL_EXPRESSION:
				sequence_RelationalExpression(context, (RelationalExpression) semanticObject); 
				return; 
			case HSFDSLPackage.STOCHASTIC_MODELING:
				sequence_StochasticModeling(context, (StochasticModeling) semanticObject); 
				return; 
			case HSFDSLPackage.STOCHSTIC_BEHAVIORS:
				sequence_StochsticBehaviors(context, (StochsticBehaviors) semanticObject); 
				return; 
			case HSFDSLPackage.STRING_LITERAL:
				sequence_StringLiteral(context, (StringLiteral) semanticObject); 
				return; 
			case HSFDSLPackage.SUM_OPERATION:
				sequence_ArithmeticExpression(context, (SumOperation) semanticObject); 
				return; 
			case HSFDSLPackage.TELLOPERATOR:
				sequence_Telloperator(context, (Telloperator) semanticObject); 
				return; 
			case HSFDSLPackage.TERM:
				sequence_Term(context, (Term) semanticObject); 
				return; 
			case HSFDSLPackage.VARIABLE_REF:
				sequence_AtomicElement(context, (VariableRef) semanticObject); 
				return; 
			case HSFDSLPackage.ATTACH_CSS:
				sequence_attachCSs(context, (attachCSs) semanticObject); 
				return; 
			case HSFDSLPackage.DETACH_CSS:
				sequence_detachCSs(context, (detachCSs) semanticObject); 
				return; 
			case HSFDSLPackage.FORMAL_PARAMETER:
				sequence_formalParameter(context, (formalParameter) semanticObject); 
				return; 
			case HSFDSLPackage.FORMAL_PARAMETER_LIST:
				sequence_formalParameterList(context, (formalParameterList) semanticObject); 
				return; 
			case HSFDSLPackage.FORMAL_PARAMETERS:
				sequence_formalParameters(context, (formalParameters) semanticObject); 
				return; 
			case HSFDSLPackage.FUNCTINALITY:
				sequence_functinality(context, (functinality) semanticObject); 
				return; 
			case HSFDSLPackage.INIT_VALS:
				sequence_initVals(context, (initVals) semanticObject); 
				return; 
			case HSFDSLPackage.PUBLICINTERFAECE_DEF:
				sequence_publicinterfaeceDef(context, (publicinterfaeceDef) semanticObject); 
				return; 
			case HSFDSLPackage.TRAIT_DECLARATION:
				sequence_traitDeclaration(context, (traitDeclaration) semanticObject); 
				return; 
			case HSFDSLPackage.VARIABLE_DECLARATOR_ID:
				sequence_variableDeclaratorId(context, (variableDeclaratorId) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AElementsBehaviorRoutines returns AElementsBehaviorRoutines
	 *
	 * Constraint:
	 *     (
	 *         CollaborativeActions+=CColActions+ 
	 *         CaolitionBinding+=attachCSs 
	 *         RemoveElements+=detachCSs 
	 *         ConnectElenents+=BindElements 
	 *         ControlDecisions+=ControlDecisions 
	 *         ActionReates+=ExponentialRates 
	 *         AddElements+=AddAElements 
	 *         HSFtypes=Expression
	 *     )
	 */
	protected void sequence_AElementsBehaviorRoutines(ISerializationContext context, AElementsBehaviorRoutines semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbsArchDecl returns AbsArchDecl
	 *
	 * Constraint:
	 *     (name=ID Mediators+=MedDecl Constitients+=CSDecl AbstractCoaltion+=AElementsBehaviorRoutines GlobalProps+=GlobalProperties)
	 */
	protected void sequence_AbsArchDecl(ISerializationContext context, AbsArchDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AddAElements returns AddAElements
	 *
	 * Constraint:
	 *     (name=ID type=ID)
	 */
	protected void sequence_AddAElements(ISerializationContext context, AddAElements semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, HSFDSLPackage.Literals.ADD_AELEMENTS__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HSFDSLPackage.Literals.ADD_AELEMENTS__NAME));
			if (transientValues.isValueTransient(semanticObject, HSFDSLPackage.Literals.ADD_AELEMENTS__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HSFDSLPackage.Literals.ADD_AELEMENTS__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAddAElementsAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getAddAElementsAccess().getTypeIDTerminalRuleCall_5_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns MinusOperation
	 *     LogicalExpression returns MinusOperation
	 *     LogicalExpression.LogicalExpression_1_0 returns MinusOperation
	 *     EqualityExpression returns MinusOperation
	 *     EqualityExpression.EqualityExpression_1_0 returns MinusOperation
	 *     RelationalExpression returns MinusOperation
	 *     RelationalExpression.RelationalExpression_1_0 returns MinusOperation
	 *     ArithmeticExpression returns MinusOperation
	 *     ArithmeticExpression.SumOperation_1_0_0_0 returns MinusOperation
	 *     ArithmeticExpression.MinusOperation_1_0_1_0 returns MinusOperation
	 *     Term returns MinusOperation
	 *     Term.Term_1_0 returns MinusOperation
	 *     Factor returns MinusOperation
	 *
	 * Constraint:
	 *     (left=ArithmeticExpression_MinusOperation_1_0_1_0 op='-' right=Term)
	 */
	protected void sequence_ArithmeticExpression(ISerializationContext context, MinusOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, HSFDSLPackage.Literals.MINUS_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HSFDSLPackage.Literals.MINUS_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, HSFDSLPackage.Literals.MINUS_OPERATION__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HSFDSLPackage.Literals.MINUS_OPERATION__OP));
			if (transientValues.isValueTransient(semanticObject, HSFDSLPackage.Literals.MINUS_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HSFDSLPackage.Literals.MINUS_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArithmeticExpressionAccess().getMinusOperationLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getArithmeticExpressionAccess().getOpHyphenMinusKeyword_1_0_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getArithmeticExpressionAccess().getRightTermParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns SumOperation
	 *     LogicalExpression returns SumOperation
	 *     LogicalExpression.LogicalExpression_1_0 returns SumOperation
	 *     EqualityExpression returns SumOperation
	 *     EqualityExpression.EqualityExpression_1_0 returns SumOperation
	 *     RelationalExpression returns SumOperation
	 *     RelationalExpression.RelationalExpression_1_0 returns SumOperation
	 *     ArithmeticExpression returns SumOperation
	 *     ArithmeticExpression.SumOperation_1_0_0_0 returns SumOperation
	 *     ArithmeticExpression.MinusOperation_1_0_1_0 returns SumOperation
	 *     Term returns SumOperation
	 *     Term.Term_1_0 returns SumOperation
	 *     Factor returns SumOperation
	 *
	 * Constraint:
	 *     (left=ArithmeticExpression_SumOperation_1_0_0_0 op='+' right=Term)
	 */
	protected void sequence_ArithmeticExpression(ISerializationContext context, SumOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, HSFDSLPackage.Literals.SUM_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HSFDSLPackage.Literals.SUM_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, HSFDSLPackage.Literals.SUM_OPERATION__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HSFDSLPackage.Literals.SUM_OPERATION__OP));
			if (transientValues.isValueTransient(semanticObject, HSFDSLPackage.Literals.SUM_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HSFDSLPackage.Literals.SUM_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArithmeticExpressionAccess().getSumOperationLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getArithmeticExpressionAccess().getOpPlusSignKeyword_1_0_0_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getArithmeticExpressionAccess().getRightTermParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Askopeator returns Askopeator
	 *
	 * Constraint:
	 *     (ConstraintData=types rate=[ExponentialRates|ID])
	 */
	protected void sequence_Askopeator(ISerializationContext context, Askopeator semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, HSFDSLPackage.Literals.ASKOPEATOR__CONSTRAINT_DATA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HSFDSLPackage.Literals.ASKOPEATOR__CONSTRAINT_DATA));
			if (transientValues.isValueTransient(semanticObject, HSFDSLPackage.Literals.ASKOPEATOR__RATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HSFDSLPackage.Literals.ASKOPEATOR__RATE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAskopeatorAccess().getConstraintDataTypesParserRuleCall_1_2_0(), semanticObject.getConstraintData());
		feeder.accept(grammarAccess.getAskopeatorAccess().getRateExponentialRatesIDTerminalRuleCall_1_4_0_1(), semanticObject.eGet(HSFDSLPackage.Literals.ASKOPEATOR__RATE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns VariableRef
	 *     LogicalExpression returns VariableRef
	 *     LogicalExpression.LogicalExpression_1_0 returns VariableRef
	 *     EqualityExpression returns VariableRef
	 *     EqualityExpression.EqualityExpression_1_0 returns VariableRef
	 *     RelationalExpression returns VariableRef
	 *     RelationalExpression.RelationalExpression_1_0 returns VariableRef
	 *     ArithmeticExpression returns VariableRef
	 *     ArithmeticExpression.SumOperation_1_0_0_0 returns VariableRef
	 *     ArithmeticExpression.MinusOperation_1_0_1_0 returns VariableRef
	 *     Term returns VariableRef
	 *     Term.Term_1_0 returns VariableRef
	 *     Factor returns VariableRef
	 *     AtomicElement returns VariableRef
	 *
	 * Constraint:
	 *     variable=ID
	 */
	protected void sequence_AtomicElement(ISerializationContext context, VariableRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, HSFDSLPackage.Literals.VARIABLE_REF__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HSFDSLPackage.Literals.VARIABLE_REF__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicElementAccess().getVariableIDTerminalRuleCall_1_1_0(), semanticObject.getVariable());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BindElements returns BindElements
	 *
	 * Constraint:
	 *     (bindParam1+=Expression bindParam2+=Expression)
	 */
	protected void sequence_BindElements(ISerializationContext context, BindElements semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BooleanLiteral
	 *     LogicalExpression returns BooleanLiteral
	 *     LogicalExpression.LogicalExpression_1_0 returns BooleanLiteral
	 *     EqualityExpression returns BooleanLiteral
	 *     EqualityExpression.EqualityExpression_1_0 returns BooleanLiteral
	 *     RelationalExpression returns BooleanLiteral
	 *     RelationalExpression.RelationalExpression_1_0 returns BooleanLiteral
	 *     ArithmeticExpression returns BooleanLiteral
	 *     ArithmeticExpression.SumOperation_1_0_0_0 returns BooleanLiteral
	 *     ArithmeticExpression.MinusOperation_1_0_1_0 returns BooleanLiteral
	 *     Term returns BooleanLiteral
	 *     Term.Term_1_0 returns BooleanLiteral
	 *     Factor returns BooleanLiteral
	 *     AtomicElement returns BooleanLiteral
	 *     LiteralElement returns BooleanLiteral
	 *     BooleanLiteral returns BooleanLiteral
	 *
	 * Constraint:
	 *     (value='true' | value='false')
	 */
	protected void sequence_BooleanLiteral(ISerializationContext context, BooleanLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CColActions returns CColActions
	 *
	 * Constraint:
	 *     (name=ID type+=types paramsDecl+=formalParameters methodBody+=functinality+)
	 */
	protected void sequence_CColActions(ISerializationContext context, CColActions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CConsDecl returns CConsDecl
	 *
	 * Constraint:
	 *     ((name=ID Askconstraints+=Askopeator) | Tellconstraints+=Telloperator)
	 */
	protected void sequence_CConsDecl(ISerializationContext context, CConsDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CSDecl returns CSDecl
	 *
	 * Constraint:
	 *     (name=ID CSDesignConsists+=CSMembersDefintion)
	 */
	protected void sequence_CSDecl(ISerializationContext context, CSDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CSMembersDefintion returns CSMembersDefintion
	 *
	 * Constraint:
	 *     (Ports+=ProtDeclaration AActions+=AElementsBehaviorRoutines CSConConstraints+=CConsDecl? CSCoreBehavior+=StochsticBehaviors*)
	 */
	protected void sequence_CSMembersDefintion(ISerializationContext context, CSMembersDefintion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ControlDecisions returns ControlDecisions
	 *
	 * Constraint:
	 *     (
	 *         expressionDecl=AElementsBehaviorRoutines? 
	 *         statementDecl1+=AElementsBehaviorRoutines+ 
	 *         (expressionOrDecl+=AElementsBehaviorRoutines? statementDecl2+=AElementsBehaviorRoutines)* 
	 *         expressionOrDecl+=AElementsBehaviorRoutines? 
	 *         statementDecl2+=AElementsBehaviorRoutines+
	 *     )
	 */
	protected void sequence_ControlDecisions(ISerializationContext context, ControlDecisions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DefineMediationRoles returns DefineMediationRoles
	 *
	 * Constraint:
	 *     (type=portandRoleType PubliicIntractionpointare+=[publicinterfaeceDef|ID] name=ID)
	 */
	protected void sequence_DefineMediationRoles(ISerializationContext context, DefineMediationRoles semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns EqualityExpression
	 *     LogicalExpression returns EqualityExpression
	 *     LogicalExpression.LogicalExpression_1_0 returns EqualityExpression
	 *     EqualityExpression returns EqualityExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns EqualityExpression
	 *     RelationalExpression returns EqualityExpression
	 *     RelationalExpression.RelationalExpression_1_0 returns EqualityExpression
	 *     ArithmeticExpression returns EqualityExpression
	 *     ArithmeticExpression.SumOperation_1_0_0_0 returns EqualityExpression
	 *     ArithmeticExpression.MinusOperation_1_0_1_0 returns EqualityExpression
	 *     Term returns EqualityExpression
	 *     Term.Term_1_0 returns EqualityExpression
	 *     Factor returns EqualityExpression
	 *
	 * Constraint:
	 *     (left=EqualityExpression_EqualityExpression_1_0 (op='==' | op='!=') right=RelationalExpression)
	 */
	protected void sequence_EqualityExpression(ISerializationContext context, EqualityExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExponentialRates returns ExponentialRates
	 *
	 * Constraint:
	 *     (delayValue=INT | ExponentialRates=Expression)
	 */
	protected void sequence_ExponentialRates(ISerializationContext context, ExponentialRates semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     initVals returns FLOAT
	 *     FLOAT returns FLOAT
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_FLOAT(ISerializationContext context, FLOAT semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, HSFDSLPackage.Literals.FLOAT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HSFDSLPackage.Literals.FLOAT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFLOATAccess().getValueINTTerminalRuleCall_0_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GlobalProperties returns GlobalProperties
	 *
	 * Constraint:
	 *     (PropertyType=types name=ID attrinit=initVals)
	 */
	protected void sequence_GlobalProperties(ISerializationContext context, GlobalProperties semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, HSFDSLPackage.Literals.GLOBAL_PROPERTIES__PROPERTY_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HSFDSLPackage.Literals.GLOBAL_PROPERTIES__PROPERTY_TYPE));
			if (transientValues.isValueTransient(semanticObject, HSFDSLPackage.Literals.GLOBAL_PROPERTIES__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HSFDSLPackage.Literals.GLOBAL_PROPERTIES__NAME));
			if (transientValues.isValueTransient(semanticObject, HSFDSLPackage.Literals.GLOBAL_PROPERTIES__ATTRINIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HSFDSLPackage.Literals.GLOBAL_PROPERTIES__ATTRINIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGlobalPropertiesAccess().getPropertyTypeTypesParserRuleCall_2_0(), semanticObject.getPropertyType());
		feeder.accept(grammarAccess.getGlobalPropertiesAccess().getNameIDTerminalRuleCall_3_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getGlobalPropertiesAccess().getAttrinitInitValsParserRuleCall_5_0(), semanticObject.getAttrinit());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns IntegerLiteral
	 *     LogicalExpression returns IntegerLiteral
	 *     LogicalExpression.LogicalExpression_1_0 returns IntegerLiteral
	 *     EqualityExpression returns IntegerLiteral
	 *     EqualityExpression.EqualityExpression_1_0 returns IntegerLiteral
	 *     RelationalExpression returns IntegerLiteral
	 *     RelationalExpression.RelationalExpression_1_0 returns IntegerLiteral
	 *     ArithmeticExpression returns IntegerLiteral
	 *     ArithmeticExpression.SumOperation_1_0_0_0 returns IntegerLiteral
	 *     ArithmeticExpression.MinusOperation_1_0_1_0 returns IntegerLiteral
	 *     Term returns IntegerLiteral
	 *     Term.Term_1_0 returns IntegerLiteral
	 *     Factor returns IntegerLiteral
	 *     AtomicElement returns IntegerLiteral
	 *     LiteralElement returns IntegerLiteral
	 *     IntegerLiteral returns IntegerLiteral
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_IntegerLiteral(ISerializationContext context, IntegerLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, HSFDSLPackage.Literals.INTEGER_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HSFDSLPackage.Literals.INTEGER_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntegerLiteralAccess().getValueINTTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns LogicalExpression
	 *     LogicalExpression returns LogicalExpression
	 *     LogicalExpression.LogicalExpression_1_0 returns LogicalExpression
	 *     EqualityExpression returns LogicalExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns LogicalExpression
	 *     RelationalExpression returns LogicalExpression
	 *     RelationalExpression.RelationalExpression_1_0 returns LogicalExpression
	 *     ArithmeticExpression returns LogicalExpression
	 *     ArithmeticExpression.SumOperation_1_0_0_0 returns LogicalExpression
	 *     ArithmeticExpression.MinusOperation_1_0_1_0 returns LogicalExpression
	 *     Term returns LogicalExpression
	 *     Term.Term_1_0 returns LogicalExpression
	 *     Factor returns LogicalExpression
	 *
	 * Constraint:
	 *     (left=LogicalExpression_LogicalExpression_1_0 (op='||' | op='&&') right=EqualityExpression)
	 */
	protected void sequence_LogicalExpression(ISerializationContext context, LogicalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MedDecl returns MedDecl
	 *
	 * Constraint:
	 *     (name=ID MedRoles+=MedRoleDeclaration AActions+=AElementsBehaviorRoutines CSConConstraints+=CConsDecl MedCoreBehavior+=StochsticBehaviors*)
	 */
	protected void sequence_MedDecl(ISerializationContext context, MedDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MedRoleDeclaration returns MedRoleDeclaration
	 *
	 * Constraint:
	 *     MediationRoles+=DefineMediationRoles
	 */
	protected void sequence_MedRoleDeclaration(ISerializationContext context, MedRoleDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModelElementsDecaration returns ModelElementsDecaration
	 *
	 * Constraint:
	 *     (
	 *         AbstractArchModel+=AbsArchDecl* 
	 *         ConstiuenetSystemSDesign+=CSDecl* 
	 *         MediatorDesign+=MedDecl* 
	 *         ConcurrentConstraints+=CConsDecl* 
	 *         ArchitecutreElementsBehaviors+=AElementsBehaviorRoutines* 
	 *         name=QualifiedName 
	 *         Interfce+=publicinterfaeceDef 
	 *         ArchTraits+=traitDeclaration*
	 *     )
	 */
	protected void sequence_ModelElementsDecaration(ISerializationContext context, ModelElementsDecaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProtDeclaration returns ProtDeclaration
	 *
	 * Constraint:
	 *     (porttype=portandRoleType PubliicIntractionpointare=[publicinterfaeceDef|ID] name=ID)
	 */
	protected void sequence_ProtDeclaration(ISerializationContext context, ProtDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, HSFDSLPackage.Literals.PROT_DECLARATION__PORTTYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HSFDSLPackage.Literals.PROT_DECLARATION__PORTTYPE));
			if (transientValues.isValueTransient(semanticObject, HSFDSLPackage.Literals.PROT_DECLARATION__PUBLIIC_INTRACTIONPOINTARE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HSFDSLPackage.Literals.PROT_DECLARATION__PUBLIIC_INTRACTIONPOINTARE));
			if (transientValues.isValueTransient(semanticObject, HSFDSLPackage.Literals.PROT_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HSFDSLPackage.Literals.PROT_DECLARATION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProtDeclarationAccess().getPorttypePortandRoleTypeParserRuleCall_1_0(), semanticObject.getPorttype());
		feeder.accept(grammarAccess.getProtDeclarationAccess().getPubliicIntractionpointarePublicinterfaeceDefIDTerminalRuleCall_3_0_1(), semanticObject.eGet(HSFDSLPackage.Literals.PROT_DECLARATION__PUBLIIC_INTRACTIONPOINTARE, false));
		feeder.accept(grammarAccess.getProtDeclarationAccess().getNameIDTerminalRuleCall_4_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns RealLiteral
	 *     LogicalExpression returns RealLiteral
	 *     LogicalExpression.LogicalExpression_1_0 returns RealLiteral
	 *     EqualityExpression returns RealLiteral
	 *     EqualityExpression.EqualityExpression_1_0 returns RealLiteral
	 *     RelationalExpression returns RealLiteral
	 *     RelationalExpression.RelationalExpression_1_0 returns RealLiteral
	 *     ArithmeticExpression returns RealLiteral
	 *     ArithmeticExpression.SumOperation_1_0_0_0 returns RealLiteral
	 *     ArithmeticExpression.MinusOperation_1_0_1_0 returns RealLiteral
	 *     Term returns RealLiteral
	 *     Term.Term_1_0 returns RealLiteral
	 *     Factor returns RealLiteral
	 *     AtomicElement returns RealLiteral
	 *     LiteralElement returns RealLiteral
	 *     RealLiteral returns RealLiteral
	 *
	 * Constraint:
	 *     value=FLOAT
	 */
	protected void sequence_RealLiteral(ISerializationContext context, RealLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, HSFDSLPackage.Literals.REAL_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HSFDSLPackage.Literals.REAL_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRealLiteralAccess().getValueFLOATParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns RelationalExpression
	 *     LogicalExpression returns RelationalExpression
	 *     LogicalExpression.LogicalExpression_1_0 returns RelationalExpression
	 *     EqualityExpression returns RelationalExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns RelationalExpression
	 *     RelationalExpression returns RelationalExpression
	 *     RelationalExpression.RelationalExpression_1_0 returns RelationalExpression
	 *     ArithmeticExpression returns RelationalExpression
	 *     ArithmeticExpression.SumOperation_1_0_0_0 returns RelationalExpression
	 *     ArithmeticExpression.MinusOperation_1_0_1_0 returns RelationalExpression
	 *     Term returns RelationalExpression
	 *     Term.Term_1_0 returns RelationalExpression
	 *     Factor returns RelationalExpression
	 *
	 * Constraint:
	 *     (left=RelationalExpression_RelationalExpression_1_0 (op='>=' | op='<=' | op='>' | op='<') right=ArithmeticExpression)
	 */
	protected void sequence_RelationalExpression(ISerializationContext context, RelationalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StochasticModeling returns StochasticModeling
	 *
	 * Constraint:
	 *     StochasticModelElements+=ModelElementsDecaration
	 */
	protected void sequence_StochasticModeling(ISerializationContext context, StochasticModeling semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StochsticBehaviors returns StochsticBehaviors
	 *
	 * Constraint:
	 *     (type=types name=ID paramsDecl=formalParameters functions+=AElementsBehaviorRoutines)
	 */
	protected void sequence_StochsticBehaviors(ISerializationContext context, StochsticBehaviors semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns StringLiteral
	 *     LogicalExpression returns StringLiteral
	 *     LogicalExpression.LogicalExpression_1_0 returns StringLiteral
	 *     EqualityExpression returns StringLiteral
	 *     EqualityExpression.EqualityExpression_1_0 returns StringLiteral
	 *     RelationalExpression returns StringLiteral
	 *     RelationalExpression.RelationalExpression_1_0 returns StringLiteral
	 *     ArithmeticExpression returns StringLiteral
	 *     ArithmeticExpression.SumOperation_1_0_0_0 returns StringLiteral
	 *     ArithmeticExpression.MinusOperation_1_0_1_0 returns StringLiteral
	 *     Term returns StringLiteral
	 *     Term.Term_1_0 returns StringLiteral
	 *     Factor returns StringLiteral
	 *     AtomicElement returns StringLiteral
	 *     LiteralElement returns StringLiteral
	 *     StringLiteral returns StringLiteral
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_StringLiteral(ISerializationContext context, StringLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, HSFDSLPackage.Literals.STRING_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HSFDSLPackage.Literals.STRING_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringLiteralAccess().getValueSTRINGTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Telloperator returns Telloperator
	 *
	 * Constraint:
	 *     (ConstraintShareDate=types rate=[ExponentialRates|ID])
	 */
	protected void sequence_Telloperator(ISerializationContext context, Telloperator semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, HSFDSLPackage.Literals.TELLOPERATOR__CONSTRAINT_SHARE_DATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HSFDSLPackage.Literals.TELLOPERATOR__CONSTRAINT_SHARE_DATE));
			if (transientValues.isValueTransient(semanticObject, HSFDSLPackage.Literals.TELLOPERATOR__RATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HSFDSLPackage.Literals.TELLOPERATOR__RATE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTelloperatorAccess().getConstraintShareDateTypesParserRuleCall_1_2_0(), semanticObject.getConstraintShareDate());
		feeder.accept(grammarAccess.getTelloperatorAccess().getRateExponentialRatesIDTerminalRuleCall_1_4_0_1(), semanticObject.eGet(HSFDSLPackage.Literals.TELLOPERATOR__RATE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Term
	 *     LogicalExpression returns Term
	 *     LogicalExpression.LogicalExpression_1_0 returns Term
	 *     EqualityExpression returns Term
	 *     EqualityExpression.EqualityExpression_1_0 returns Term
	 *     RelationalExpression returns Term
	 *     RelationalExpression.RelationalExpression_1_0 returns Term
	 *     ArithmeticExpression returns Term
	 *     ArithmeticExpression.SumOperation_1_0_0_0 returns Term
	 *     ArithmeticExpression.MinusOperation_1_0_1_0 returns Term
	 *     Term returns Term
	 *     Term.Term_1_0 returns Term
	 *     Factor returns Term
	 *
	 * Constraint:
	 *     (left=Term_Term_1_0 (op='*' | op='/' | op='mod') right=Factor)
	 */
	protected void sequence_Term(ISerializationContext context, Term semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NegationExpression
	 *     LogicalExpression returns NegationExpression
	 *     LogicalExpression.LogicalExpression_1_0 returns NegationExpression
	 *     EqualityExpression returns NegationExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns NegationExpression
	 *     RelationalExpression returns NegationExpression
	 *     RelationalExpression.RelationalExpression_1_0 returns NegationExpression
	 *     ArithmeticExpression returns NegationExpression
	 *     ArithmeticExpression.SumOperation_1_0_0_0 returns NegationExpression
	 *     ArithmeticExpression.MinusOperation_1_0_1_0 returns NegationExpression
	 *     Term returns NegationExpression
	 *     Term.Term_1_0 returns NegationExpression
	 *     Factor returns NegationExpression
	 *     UnaryExpression returns NegationExpression
	 *
	 * Constraint:
	 *     expression=AtomicElement
	 */
	protected void sequence_UnaryExpression(ISerializationContext context, NegationExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, HSFDSLPackage.Literals.NEGATION_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HSFDSLPackage.Literals.NEGATION_EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryExpressionAccess().getExpressionAtomicElementParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     attachCSs returns attachCSs
	 *
	 * Constraint:
	 *     (attachParam1+=Expression attachParam2+=Expression)
	 */
	protected void sequence_attachCSs(ISerializationContext context, attachCSs semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     detachCSs returns detachCSs
	 *
	 * Constraint:
	 *     (detachParam1+=Expression detachParam2+=Expression)
	 */
	protected void sequence_detachCSs(ISerializationContext context, detachCSs semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     formalParameterList returns formalParameterList
	 *
	 * Constraint:
	 *     (paramDecl=formalParameter paramsDecl+=formalParameter*)
	 */
	protected void sequence_formalParameterList(ISerializationContext context, formalParameterList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     formalParameter returns formalParameter
	 *
	 * Constraint:
	 *     (type=types name=variableDeclaratorId)
	 */
	protected void sequence_formalParameter(ISerializationContext context, formalParameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, HSFDSLPackage.Literals.FORMAL_PARAMETER__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HSFDSLPackage.Literals.FORMAL_PARAMETER__TYPE));
			if (transientValues.isValueTransient(semanticObject, HSFDSLPackage.Literals.FORMAL_PARAMETER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HSFDSLPackage.Literals.FORMAL_PARAMETER__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFormalParameterAccess().getTypeTypesParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getFormalParameterAccess().getNameVariableDeclaratorIdParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     formalParameters returns formalParameters
	 *
	 * Constraint:
	 *     paramsDecl+=formalParameterList?
	 */
	protected void sequence_formalParameters(ISerializationContext context, formalParameters semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     functinality returns functinality
	 *
	 * Constraint:
	 *     (functions+=AElementsBehaviorRoutines* Actions=[functinality|ID] target=[ExponentialRates|ID])
	 */
	protected void sequence_functinality(ISerializationContext context, functinality semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     initVals returns initVals
	 *
	 * Constraint:
	 *     {initVals}
	 */
	protected void sequence_initVals(ISerializationContext context, initVals semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     publicinterfaeceDef returns publicinterfaeceDef
	 *
	 * Constraint:
	 *     (Name=ID paramsDecl=formalParameters)
	 */
	protected void sequence_publicinterfaeceDef(ISerializationContext context, publicinterfaeceDef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, HSFDSLPackage.Literals.PUBLICINTERFAECE_DEF__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HSFDSLPackage.Literals.PUBLICINTERFAECE_DEF__NAME));
			if (transientValues.isValueTransient(semanticObject, HSFDSLPackage.Literals.PUBLICINTERFAECE_DEF__PARAMS_DECL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HSFDSLPackage.Literals.PUBLICINTERFAECE_DEF__PARAMS_DECL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPublicinterfaeceDefAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPublicinterfaeceDefAccess().getParamsDeclFormalParametersParserRuleCall_3_0(), semanticObject.getParamsDecl());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     traitDeclaration returns traitDeclaration
	 *
	 * Constraint:
	 *     (name=ID ports+=ProtDeclaration roles+=MedRoleDeclaration)
	 */
	protected void sequence_traitDeclaration(ISerializationContext context, traitDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     variableDeclaratorId returns variableDeclaratorId
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_variableDeclaratorId(ISerializationContext context, variableDeclaratorId semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, HSFDSLPackage.Literals.VARIABLE_DECLARATOR_ID__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HSFDSLPackage.Literals.VARIABLE_DECLARATOR_ID__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableDeclaratorIdAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
}
